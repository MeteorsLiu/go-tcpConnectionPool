# 这是什么?（WTF it is?)

这是一个 为 **客户端** 设计的 TCP连接池。（没有服务端，是因为我觉得Golang服务端不需要连接池，每一个连接独立一个goroutine即可。

为了解决多Goroutine下对TCP读写的问题。

例如

Relay等工具。

他们往往一下子涌入一大堆连接。此时，解决办法有Ring Buffer，或者新建连接。

但是随意滥开连接会导致TCP连接太多触发系统 HARD/SOFT LIMITS。

那么为什么不用ring buffer？我认为，goroutine就是一个设计很好的队列，其次，数据就不应该被放入内存中等待太久，就应该立刻发送，以便降低时延。

所以这个连接池就诞生了。目的就是为了解决在高并发环境下TCP写问题。

我是如何解决写问题的？

通过互斥锁，但是互斥锁会自旋，会休眠，如果连接很多，这些在抢锁的过程中也会产生较大时延。

但是得益于Go 1.18新加入的TryLock函数，我们可以不进行抢锁的过程，如果这个连接繁忙，跳过，进行下一个。

如果全部都很繁忙（也就是互斥锁全都锁上了），那么就会尝试新建连接。

默认会创建16个连接，在我本人测试下(8核心机器)，开500个goroutine，16个连接完全绰绰有余，最多只会用到前3个。

那么读呢？

V1版本的连接池并没有考虑到这个问题。

因为那么多个连接，不可能一个个开一个goroutine去等待。

因此，我引入了系统的epoll通知钩子，通过epoll来获取可以读的连接，并且将它们放入一个Readable Queue（可读队列，默认长度1024）中，来供不同的goroutine读。




